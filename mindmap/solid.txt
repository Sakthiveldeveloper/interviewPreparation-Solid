=================================
SRP → Maintainable & focused code
OCP → Extensible without breaking old code
LSP → Reliable inheritance
ISP → Clean, minimal interfaces
DIP → Flexible & loosely coupled architecture
-=================================
1. S → Single Responsibility Principle
👶 "One toy = one job."
A toy car is for driving 🚗
A toy plane is for flying ✈️
Don’t mix them together in one block.
➡️ Each class should do only one thing.
O → Open/Closed Principle
👶 "Keep toy safe, but add new blocks."
You can add more LEGO pieces to make a bigger house 🏠
But you don’t break the old house.
➡️ Code should be open to adding new features but closed to breaking old code.
3. L → Liskov Substitution Principle
👶 "Baby duck should act like mama duck." 🦆
If you say "this is a duck," it should quack and swim like a duck.
A toy duck should not suddenly act like a cat 🐱.
➡️ A child class must behave like its parent.
4. I → Interface Segregation Principle
👶 "Don’t give baby too many buttons."
Remote control with 2 buttons (on/off) ✅ easy.
Remote control with 100 buttons ❌ confusing.
➡️ Make small, simple interfaces, not one giant messy one.
D → Dependency Inversion Principle
👶 "Play with shapes, not with exact toys."
You say "I want something round" 🔵 (abstract idea).
Then you can play with a ball, a wheel, or an orange.
➡️ Big parts of code should depend on ideas (interfaces), not on tiny details.
🎉 Baby Takeaway:

S → One job only 👷
O → Add new, don’t break old ➕
L → Kids act like parents 👨‍👧
I → Small & simple remotes 🎮
D → Play with ideas, not details 💡 
------------------------------------------------
SOLID Principles
├── 1. S – Single Responsibility Principle (SRP)
│   ├── Definition → A class/component should have one reason to change
│   ├── Benefits → Clean code, easier debugging, reusability
│   ├── Examples
│   │   ├── ✅ Split React components (UI vs logic)
│   │   ├── ✅ Separate services (AuthService, UserService)
│   │   └── ❌ Fat components handling UI + API + state
│   └── Related Concepts → Separation of Concerns, DRY
│
├── 2. O – Open/Closed Principle (OCP)
│   ├── Definition → Software entities should be open for extension, closed for modification
│   ├── Benefits → Scalability, avoids regression
│   ├── Examples
│   │   ├── ✅ Add new features via hooks/custom HOCs instead of editing core logic
│   │   ├── ✅ Use strategy pattern instead of `if/else` chains
│   │   └── ❌ Changing core component logic for every new requirement
│   └── Related Concepts → Polymorphism, Plugins
│
├── 3. L – Liskov Substitution Principle (LSP)
│   ├── Definition → Subtypes must be substitutable for their base types
│   ├── Benefits → Reliability, predictable behavior
│   ├── Examples
│   │   ├── ✅ Derived React component respects base component contract
│   │   ├── ✅ Functions expecting a `Shape` should work with `Circle` or `Square`
│   │   └── ❌ Child overrides parent behavior in unexpected way (e.g., returns null where parent guarantees a value)
│   └── Related Concepts → Inheritance, Interface Contracts
│
├── 4. I – Interface Segregation Principle (ISP)
│   ├── Definition → Clients should not be forced to depend on interfaces they don’t use
│   ├── Benefits → Cleaner APIs, reduced coupling
│   ├── Examples
│   │   ├── ✅ Split big context into smaller ones (ThemeContext, AuthContext)
│   │   ├── ✅ Create smaller service interfaces (PaymentService, NotificationService)
│   │   └── ❌ One giant API service with unused methods
│   └── Related Concepts → Composition over inheritance
│
├── 5. D – Dependency Inversion Principle (DIP)
│   ├── Definition → Depend on abstractions, not concrete implementations
│   ├── Benefits → Testability, flexibility, loose coupling
│   ├── Examples
│   │   ├── ✅ Inject service dependencies via props/context/hooks
│   │   ├── ✅ Use abstraction layers (API client interface) instead of direct axios/fetch calls
│   │   └── ❌ Component directly tied to database/axios logic
│   └── Related Concepts → Dependency Injection, Inversion of Control
│
└── 6. Cross-Cutting Ideas
    ├── Design Patterns → Strategy, Observer, Factory, Adapter
    ├── Applied in → React components, Node services, APIs
    ├── Benefits → Scalability, Maintainability, Testability
    └── Anti-patterns → God object, Tight coupling, Over-engineering
