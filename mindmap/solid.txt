=================================
SRP â†’ Maintainable & focused code
OCP â†’ Extensible without breaking old code
LSP â†’ Reliable inheritance
ISP â†’ Clean, minimal interfaces
DIP â†’ Flexible & loosely coupled architecture
-=================================
1. S â†’ Single Responsibility Principle
ğŸ‘¶ "One toy = one job."
A toy car is for driving ğŸš—
A toy plane is for flying âœˆï¸
Donâ€™t mix them together in one block.
â¡ï¸ Each class should do only one thing.
O â†’ Open/Closed Principle
ğŸ‘¶ "Keep toy safe, but add new blocks."
You can add more LEGO pieces to make a bigger house ğŸ 
But you donâ€™t break the old house.
â¡ï¸ Code should be open to adding new features but closed to breaking old code.
3. L â†’ Liskov Substitution Principle
ğŸ‘¶ "Baby duck should act like mama duck." ğŸ¦†
If you say "this is a duck," it should quack and swim like a duck.
A toy duck should not suddenly act like a cat ğŸ±.
â¡ï¸ A child class must behave like its parent.
4. I â†’ Interface Segregation Principle
ğŸ‘¶ "Donâ€™t give baby too many buttons."
Remote control with 2 buttons (on/off) âœ… easy.
Remote control with 100 buttons âŒ confusing.
â¡ï¸ Make small, simple interfaces, not one giant messy one.
D â†’ Dependency Inversion Principle
ğŸ‘¶ "Play with shapes, not with exact toys."
You say "I want something round" ğŸ”µ (abstract idea).
Then you can play with a ball, a wheel, or an orange.
â¡ï¸ Big parts of code should depend on ideas (interfaces), not on tiny details.
ğŸ‰ Baby Takeaway:

S â†’ One job only ğŸ‘·
O â†’ Add new, donâ€™t break old â•
L â†’ Kids act like parents ğŸ‘¨â€ğŸ‘§
I â†’ Small & simple remotes ğŸ®
D â†’ Play with ideas, not details ğŸ’¡ 
------------------------------------------------
SOLID Principles
â”œâ”€â”€ 1. S â€“ Single Responsibility Principle (SRP)
â”‚   â”œâ”€â”€ Definition â†’ A class/component should have one reason to change
â”‚   â”œâ”€â”€ Benefits â†’ Clean code, easier debugging, reusability
â”‚   â”œâ”€â”€ Examples
â”‚   â”‚   â”œâ”€â”€ âœ… Split React components (UI vs logic)
â”‚   â”‚   â”œâ”€â”€ âœ… Separate services (AuthService, UserService)
â”‚   â”‚   â””â”€â”€ âŒ Fat components handling UI + API + state
â”‚   â””â”€â”€ Related Concepts â†’ Separation of Concerns, DRY
â”‚
â”œâ”€â”€ 2. O â€“ Open/Closed Principle (OCP)
â”‚   â”œâ”€â”€ Definition â†’ Software entities should be open for extension, closed for modification
â”‚   â”œâ”€â”€ Benefits â†’ Scalability, avoids regression
â”‚   â”œâ”€â”€ Examples
â”‚   â”‚   â”œâ”€â”€ âœ… Add new features via hooks/custom HOCs instead of editing core logic
â”‚   â”‚   â”œâ”€â”€ âœ… Use strategy pattern instead of `if/else` chains
â”‚   â”‚   â””â”€â”€ âŒ Changing core component logic for every new requirement
â”‚   â””â”€â”€ Related Concepts â†’ Polymorphism, Plugins
â”‚
â”œâ”€â”€ 3. L â€“ Liskov Substitution Principle (LSP)
â”‚   â”œâ”€â”€ Definition â†’ Subtypes must be substitutable for their base types
â”‚   â”œâ”€â”€ Benefits â†’ Reliability, predictable behavior
â”‚   â”œâ”€â”€ Examples
â”‚   â”‚   â”œâ”€â”€ âœ… Derived React component respects base component contract
â”‚   â”‚   â”œâ”€â”€ âœ… Functions expecting a `Shape` should work with `Circle` or `Square`
â”‚   â”‚   â””â”€â”€ âŒ Child overrides parent behavior in unexpected way (e.g., returns null where parent guarantees a value)
â”‚   â””â”€â”€ Related Concepts â†’ Inheritance, Interface Contracts
â”‚
â”œâ”€â”€ 4. I â€“ Interface Segregation Principle (ISP)
â”‚   â”œâ”€â”€ Definition â†’ Clients should not be forced to depend on interfaces they donâ€™t use
â”‚   â”œâ”€â”€ Benefits â†’ Cleaner APIs, reduced coupling
â”‚   â”œâ”€â”€ Examples
â”‚   â”‚   â”œâ”€â”€ âœ… Split big context into smaller ones (ThemeContext, AuthContext)
â”‚   â”‚   â”œâ”€â”€ âœ… Create smaller service interfaces (PaymentService, NotificationService)
â”‚   â”‚   â””â”€â”€ âŒ One giant API service with unused methods
â”‚   â””â”€â”€ Related Concepts â†’ Composition over inheritance
â”‚
â”œâ”€â”€ 5. D â€“ Dependency Inversion Principle (DIP)
â”‚   â”œâ”€â”€ Definition â†’ Depend on abstractions, not concrete implementations
â”‚   â”œâ”€â”€ Benefits â†’ Testability, flexibility, loose coupling
â”‚   â”œâ”€â”€ Examples
â”‚   â”‚   â”œâ”€â”€ âœ… Inject service dependencies via props/context/hooks
â”‚   â”‚   â”œâ”€â”€ âœ… Use abstraction layers (API client interface) instead of direct axios/fetch calls
â”‚   â”‚   â””â”€â”€ âŒ Component directly tied to database/axios logic
â”‚   â””â”€â”€ Related Concepts â†’ Dependency Injection, Inversion of Control
â”‚
â””â”€â”€ 6. Cross-Cutting Ideas
    â”œâ”€â”€ Design Patterns â†’ Strategy, Observer, Factory, Adapter
    â”œâ”€â”€ Applied in â†’ React components, Node services, APIs
    â”œâ”€â”€ Benefits â†’ Scalability, Maintainability, Testability
    â””â”€â”€ Anti-patterns â†’ God object, Tight coupling, Over-engineering
